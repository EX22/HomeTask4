# HomeTask4
Java 0. Task OOP
Задание. Объектно-ориентированное программирование.
Необходимо написать объектно-ориентированное приложение согласно ниже приведённым требованиям.

В приложении должна быть реализована следующая функциональность:

Вариант 4.

Игровая комната.
Подготовить игровую комнату для детей разных возрастных групп.
Игрушек должно быть фиксированное количество в пределах выделенной суммы денег.
Должны встречаться игрушки различных категорий: маленькие, средние и большие машины, куклы, мячи, кубики.
Провести сортировку игрушек на основе одного и нескольких параметров.
Найти игрушки в комнате, соответствующие заданным параметрам.

Требования.
1. При реализации иерархии наследования, производный класс должен расширять суперкласс новыми свойствами,
  для чего стоит разобраться в предметной области задачи. При описании полей можно использовать класс Optional.
2. Классы-сущности должны быть отделены от классов с методами бизнес-логики.
3. Использовать перечисления (enum) для описания полей с ограниченным набором значений.
4. Для сортировок наборов объектов можно использовать реализацию интерфейса Comparator и его возможности.
  В частности, thenComparing.
5. При решении задачи можно использовать паттерн Factory Method.
6. Все классы приложения должны быть грамотно структурированы по пакетам.
7. Оформление кода должно соответствовать Java Code Convention.
8. Параметры, необходимые для создания объектов, должны вводиться с помощью чтения данных из файла (.txt).
  Среди данных в файле должна быть заведомо некрорректная информация.
  Должна присутствовать обработка некорректных данных инициализации объекта.
9. Для записи логов использовать Log4J2 (Java logger не использовать).
10. Код должен быт покрыт Unit-тестами.
11. Приветствуется реализация запуска приложения с применением тестов, т.е. без метода main.

Примечания.

1) После if всегда следует положительный сценарий, после else - отрицательный.
2) Если только if, то возможен и отрицательный сценарий.
3) В if, for, while обязательно использовать {}.
4) Если генерируется exception, не ловить его сразу же.
5) В finally не генерировать исключения и не использовать return.
6) Не генерировать стандартные исключения. Разрешено только в методах private.
7) fileWriter.close(); - в блок finally.
8) Регулярные выражения в константы.
9) В именах пакетов не использовать большие буквы.
10) Не класть сторонние файлы в папки рядом или вместе с классами.
11) Размещать файлы только в папках в корне проекта.
12) Использовать для файлов только относительные пути. Папка src не должна присутствовать в пути к файлу.
13) Если константа не изменяемая, то имя должно быть в верхнем регистре, если изменяемая, то как правило
    именуется как обычное поле класса.
14) Элементы перечисления именуются как неизменяемые константы.
15) Не увлекаться статическими методами.
16) Не объявлять get-теры и set-теры абстрактными.
17) Не давать классам имена, совпадающие с именами стандартных классов и интерфейсов Java!
18) Не разделять объявление переменной и присвоение ей значения в методах.
    Пример:
    Н Е П Р А В И Л Ь Н О!
    Integer count;
    count = 0;
    
    ПРАВИЛЬНО!
    Integer count = 0;
    
19) Расстояние (в строках кода) между использованием переменной и её объявлением должно быть минимально!
20) В одной строчке - одня точка, то есть надо использовать локальные переменные.
    Пример:
    Н Е П Р А В И Л Ь Н О!
    samle.getSomething().getData();
    
    ПРАВИЛЬНО!
    Something something = sample.getSomething();
    Data data = something.getData();
    
21) Не писать: if(isValid == true), а  П И С А Т Ь: if(isValid)
22) Не писать:
    if(someValue == EXPECTED_VALUE){
      return true;
      } else {
        return false;
      }
      
    П И С А Т Ь:  return someValue == EXPECTED_VALUE;
    
23) Использовать assertEquals вместо assertTrue(some==other).
24) Использовать assertTrue(isValid) вместо assertEquals(true, isValid).
25) Лучше тестовые объекты размещать в тестах в виде констант, а не создавать их в самом методе.
26) Не использовать существующий FactoryMethod в тестах для создания объектов,
    объекты в тестах создавать через new.
27) Тест должен иметь структуру: given, when, then,
    где given - прекондишены (инициализация данных),
        when - вызов тестируемого метода (всегда одна строчка),
        then - посткондишен (assert-метод).
        
